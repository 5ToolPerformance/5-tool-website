---
// @ts-nocheck
import CoachCardNew from "./cards/CoachCardNew.astro";
import type { Image } from "../lib/types";

// TypeScript interface for the CoachCarousel class
interface CoachCarouselType {
  new (): void;
}

export interface Coach {
  name: string;
  title: string;
  image: Image;
  description: string;
  slug: {
    current: string;
    _type: string;
  };
}

export interface Props {
  coaches: Coach[];
  title?: string;
}

const { coaches, title = "Meet The Team" } = Astro.props;
---

<div class="max-w-full mx-auto">
  <div class="relative">
    <!-- Navigation Buttons -->
    <button
      id="prevBtn"
      class="absolute left-0 top-1/2 -translate-y-1/2 -translate-x-2 sm:-translate-x-10 z-10 bg-navy text-white rounded-none px-2 sm:px-3 py-3 shadow-lg hover:shadow-xl transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-carolina-300 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 hover:bg-white hover:text-navy border border-transparent"
      aria-label="Previous coaches"
    >
      <svg
        class="w-6 h-6"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M15 19l-7-7 7-7"></path>
      </svg>
    </button>

    <button
      id="nextBtn"
      class="absolute right-0 top-1/2 -translate-y-1/2 translate-x-2 sm:translate-x-14 z-10 bg-navy text-white rounded-none px-2 sm:px-3 py-3 shadow-lg hover:shadow-xl transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-carolina-300 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 hover:bg-white hover:text-navy border border-transparent"
      aria-label="Next coaches"
    >
      <svg
        class="w-6 h-6"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M9 5l7 7-7 7"></path>
      </svg>
    </button>

    <!-- Carousel Container -->
    <div class="overflow-hidden px-4 pb-1 w-full">
      <div
        id="carousel"
        class="flex transition-transform duration-300 ease-in-out -mx-3 sm:-mx-4"
      >
        {
          coaches.map((coach, index) => (
            <div class="flex-shrink-0 w-full sm:w-1/2 lg:w-1/3 xl:w-1/4">
              <div class="h-full px-3 sm:px-4">
                <CoachCardNew {...coach} />
              </div>
            </div>
          ))
        }
      </div>
    </div>

    <!-- Dots Indicator -->
    <div
      id="dotsContainer"
      class="flex justify-center items-center mt-10 space-x-2"
    >
    </div>
  </div>
</div>

<script>
  class CoachCarousel {
    carousel: HTMLElement | null = null;
    prevBtn: HTMLButtonElement | null = null;
    nextBtn: HTMLButtonElement | null = null;
    dotsContainer: HTMLElement | null = null;
    currentIndex = 0;
    itemsPerView = 0;
    totalItems = 0;
    maxIndex = 0;
    handleResizeBound: (() => void) | null = null;
    handleTouchStartBound: ((e: TouchEvent) => void) | null = null;

    constructor() {
      this.carousel = document.getElementById("carousel");
      this.prevBtn = document.getElementById("prevBtn") as HTMLButtonElement;
      this.nextBtn = document.getElementById("nextBtn") as HTMLButtonElement;
      this.dotsContainer = document.getElementById("dotsContainer");

      if (!this.carousel || !this.prevBtn || !this.nextBtn) {
        console.error("Required carousel elements not found");
        return;
      }

      this.currentIndex = 0;
      this.itemsPerView = this.getItemsPerView();
      this.totalItems = this.carousel.children.length;
      this.maxIndex = Math.max(0, this.totalItems - this.itemsPerView);

      this.handleResizeBound = this.handleResize.bind(this);
      this.handleTouchStartBound = this.handleTouchStart.bind(this);

      this.init();
    }

    getItemsPerView() {
      const width = window.innerWidth;
      if (width >= 1280) return 4; // xl
      if (width >= 1024) return 3; // lg
      if (width >= 640) return 2; // sm
      return 1;
    }

    init() {
      this.createDots();
      this.updateCarousel();
      this.bindEvents();
    }

    createDots() {
      if (!this.dotsContainer) return;

      this.dotsContainer.innerHTML = "";
      const numDots = Math.ceil(this.totalItems / this.itemsPerView);

      for (let i = 0; i < numDots; i++) {
        const dot = document.createElement("button");
        dot.className =
          "w-2.5 h-2.5 rounded-full transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-carolina-300 mx-1";
        dot.setAttribute("aria-label", `Go to slide ${i + 1}`);
        dot.addEventListener("click", () => this.goToSlide(i));
        this.dotsContainer.appendChild(dot);
      }

      this.updateDots();
    }

    updateDots() {
      if (!this.dotsContainer) return;

      const dots = this.dotsContainer.children;
      const activeDotIndex = Math.floor(this.currentIndex / this.itemsPerView);

      for (let i = 0; i < dots.length; i++) {
        if (i === activeDotIndex) {
          dots[i].className = dots[i].className.replace(
            "bg-carolina-300",
            "bg-white"
          );
          if (!dots[i].className.includes("bg-white")) {
            dots[i].className += " bg-white";
          }
        } else {
          dots[i].className = dots[i].className.replace(
            "bg-white",
            "bg-carolina-300/50"
          );
          if (
            !dots[i].className.includes("bg-carolina-300/50") &&
            !dots[i].className.includes("bg-white")
          ) {
            dots[i].className += " bg-carolina-300/50";
          }
        }
      }
    }

    updateCarousel() {
      if (!this.carousel) return;

      // Calculate the width of each item based on the number of items per view
      const itemWidth = 100 / this.itemsPerView;
      // Calculate the total width that needs to be translated
      const translateX = -(this.currentIndex * itemWidth);

      // Apply the transform with a smooth transition
      this.carousel.style.transform = `translateX(${translateX}%)`;

      // Update button states
      if (this.prevBtn) this.prevBtn.disabled = this.currentIndex === 0;
      if (this.nextBtn)
        this.nextBtn.disabled = this.currentIndex >= this.maxIndex;

      this.updateDots();
    }

    next() {
      if (this.currentIndex < this.maxIndex) {
        this.currentIndex = Math.min(this.currentIndex + 1, this.maxIndex);
        this.updateCarousel();
      }
    }

    prev() {
      if (this.currentIndex > 0) {
        this.currentIndex = Math.max(this.currentIndex - 1, 0);
        this.updateCarousel();
      }
    }

    goToSlide(slideIndex: number) {
      this.currentIndex = Math.min(
        slideIndex * this.itemsPerView,
        this.maxIndex
      );
      this.updateCarousel();
    }

    handleResize() {
      const newItemsPerView = this.getItemsPerView();
      if (newItemsPerView !== this.itemsPerView) {
        // Store the current scroll position to maintain it after resize
        const scrollPosition = this.currentIndex * (100 / this.itemsPerView);

        this.itemsPerView = newItemsPerView;
        this.maxIndex = Math.max(0, this.totalItems - this.itemsPerView);

        // Calculate the new index that maintains the scroll position
        this.currentIndex = Math.min(
          Math.round(scrollPosition / (100 / newItemsPerView)),
          this.maxIndex
        );

        this.createDots();
        this.updateCarousel();
      }
    }

    private handleTouchStart(e: TouchEvent) {
      const startX = e.touches[0].clientX;
      let endX = 0;

      const handleTouchMove = (moveEvent: TouchEvent) => {
        const currentX = moveEvent.touches[0].clientX;
        endX = currentX;
      };

      const handleTouchEnd = () => {
        const diff = startX - endX;

        if (Math.abs(diff) > 50) {
          // Threshold for swipe
          if (diff > 0) {
            this.next();
          } else {
            this.prev();
          }
        }

        this.carousel?.removeEventListener("touchmove", handleTouchMove);
        this.carousel?.removeEventListener(
          "touchend",
          handleTouchEnd as EventListener
        );
      };

      this.carousel?.addEventListener("touchmove", handleTouchMove, {
        passive: true,
      });
      this.carousel?.addEventListener(
        "touchend",
        handleTouchEnd as EventListener,
        { once: true }
      );
    }

    private bindEvents() {
      this.nextBtn?.addEventListener("click", () => this.next());
      this.prevBtn?.addEventListener("click", () => this.prev());

      if (this.handleResizeBound) {
        window.addEventListener("resize", this.handleResizeBound, {
          passive: true,
        });
      }
      if (this.handleTouchStartBound) {
        this.carousel?.addEventListener(
          "touchstart",
          this.handleTouchStartBound
        );
      }
    }
  }

  // Initialize carousel when DOM is loaded
  // Initialize carousel when DOM is loaded
  document.addEventListener("DOMContentLoaded", () => {
    new CoachCarousel();
  });

  // Re-initialize on page navigation (for Astro's client-side routing)
  document.addEventListener("astro:page-load", () => {
    new CoachCarousel();
  });
</script>
